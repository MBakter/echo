@startuml UML

class Labirinth {

}

class Room implements IItemHolder{
    + maxPlayer: int

    +getNeighbours(): Room[]
    +addStudent(student: Student): void
    +removeStudent(student: Student): void
    +addTeacher(teacher: Teacher): void
    +removeTeacher(teacher: Teacher): void
    +addNeighbour(room: Room): void
    +removeNeighbour(room: Room): void
    +merge(room: Room): void
    +split(): Room
    +isFull(): boolean

    +notifyStudents(): void
    +notifyTeachers(): void

}

Room "1" o-- "0..*" Student: + students
Room "1" o-- "0..*" Teacher: + teachers
Room "1" *-- "0..*" Room: + neighbours
IItemHolder "1" *-- "0..*" Items: + items
Room *-- ERoomState: + state
Labirinth "1" *-- "0..*" Room: + rooms

abstract class Player implements IItemHolder{
  + room: Room
  + move(Room): void
}
interface IVisitor {
  + use(mask: Mask): boolean
  + use(sponge: Sponge): boolean
  + use(beer: Beer): boolean
  + use(cheese: Cheese): boolean
  + use(transistor: TransistorPair): boolean
}

class ItemVisitor {
  + saveFromTeacher(items: Item[]): boolean
  + saveFromPoison(items: Item[]): boolean
  + makeRoomPoisoned(items: Item[], room: Room): boolean
}

IVisitor <|-- ItemVisitor

abstract class Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

class TVSZ extends Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

class Beer extends Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

class TransistorPair extends Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

class Mask extends Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

class Sponge extends Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

class Cheese extends Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

class Logarlec extends Items {
  + accept(Visitor)
  + isAvaliable(): boolean
}

Items ..> IVisitor
IVisitor ..>  TVSZ
IVisitor ..>  TransistorPair
IVisitor ..>  Beer
IVisitor ..>  Cheese
IVisitor ..>  Mask
IVisitor ..>  Logarlec
IVisitor ..>  Sponge


Student ..> ItemVisitor
Student ..> Items


class Teacher extends Player{}
class Student extends Player{}



interface IItemHolder {
    + maxItem: int
    + addItemy(item: Item): void
    + removeItem(item: Item): void
}

enum ERoomState {
  OPENED
  CLOSED
  POISONED
}


@enduml
